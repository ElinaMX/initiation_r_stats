---
title: "Introduction à R"
subtitle: "Statistique descriptive univariée et bivariée"
description: "Master G2M, 2-4 septembre 2025" 
author: 
 - name: Elina Marveaux
   affiliation: Géographie-Cités, CNRS
 - name: Louis Laurian
   affiliation: UAR RIATE, CNRS
   
format:
  html:
    output-file: index.html
    embed-resources: true
    theme: yeti
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
    toc-depth: 3
    toc-title: "."
    number-sections: true
    bibliography: [biblio.bib]
    css: custom.css
    code-line-numbers: true
    code-copy: true
    code-block-bg: "#cfe8fc"
execute:
  cache: false
  warning: false
  message: false  
editor_options: 
  chunk_output_type: consoles
nocite: |
  @*
link-citations: true
---

```{r, eval=TRUE, include= TRUE, echo=FALSE, cache=TRUE}
options("scipen" = 10)

library('rvest')
url <- "https://cran.r-project.org/web/packages/available_packages_by_date.html"
#Reading the HTML code from the website
webpage <- read_html(url)
td <- webpage %>%  html_nodes("td")
rank_data <- html_text(td)

vec <- c(NULL)
for (t in seq(1,length(rank_data),3))  {
vec <-  c(vec, rank_data[t])
}

library(stringr)
vec <- str_trim(vec)
test <- as.data.frame(vec)
test$nb <- 1
test$date <- as.Date(test$vec)
test <- test[,c(3:2)]

library(plyr)
test2 <-  ddply(test, .(date), summarize, nb=sum(nb))
test2$cum <- cumsum(test2$nb)
test <- test2[,c(1:3)]


nb_function_base <- length(c(lsf.str("package:base"), lsf.str("package:graphics"), lsf.str("package:grDevices"), lsf.str("package:methods"), lsf.str("package:stats"), lsf.str("package:utils")))
```

![](figures/featured.png)

::: {.callout-note title="Objectifs de ce cours"}
1.  **Acquérir les bases du logiciel/langage R** et de son environnement RStudio
2.  Réviser les bases de la **statistique descriptive univariée et bivariée** en géographie
3.  Comprendre les atouts de R pour la **gestion, l'analyse et la représentation** de données
:::

[![](figures/diapo.png){width="10%"}](https://elementr.gitpages.huma-num.fr/session_1/Presentation_R/#/) **Diaporama** : Contextualisation et présentation de R et Rstudio

Bonus : [Base du langage, packages, Rstudio et documentation](https://huguespecout.github.io/Intro_R_Rstudio_FR/#/)

# Quelques fondamentaux

## L'interface Rstudio

**L'interface de RStudio se présente sous la forme d’une unique fenêtre découpée en quatre zones** que l’on peut redimensionner, masquer ou maximiser selon ses préférences :

::: div_voc
-   **L’éditeur de code** Cette zone permet l’édition de fichiers source R (avec coloration syntaxique et auto complétion).

-   **La console** La console avec la session R en cours d’exécution. La console affiche à la fois le code exécuté, ses résultats associés, ainsi que les avertissements (Warning) et messages d'erreur éventuels (Error).

-   **L’espace de travail** Cette zone permet de lister, typer et visualiser les objets créés par l'exécution du code R.

-   **Une quatrième zone** permettant de basculer entre : Un explorateur de fichiers, une fenêtre graphique, une fenêtre de gestion des packages et de la documentation associée aux fonctions et packages.
:::

![](figures/R_studio.png)

**RStudio propose de nombreuses fonctionnalités intéressantes, par exemple :**

::: div_voc
[**La création de projet**]{.div_voc_title}

RStudio dispose d’une fonctionnalité très pratique pour **organiser son travail en différents projets**. L’idée principale est de réunir tous les fichiers et documents relatifs à un même projet (que ce soit les données, les scripts, les rapports automatisés…) dans un répertoire dédié. L’onglet "*Projects*" est situé en haut à droite de l’interface.

[**Les boutons raccourcis**]{.div_voc_title} Plusieurs actions comme la création et le chargement de programme, l'import de données, l'installation et le chargement de packages, l’accès à la documentation, la visualisation des objets, l'export de figures... sont exécutables en un simple clic.

[**L’auto-complétion**]{.div_voc_title}

RStudio présente aussi la capacité de compléter automatiquement les termes en cours d’écriture. L’auto-complétion fonctionne avec la touche ***Tab*** du clavier. Cela aide l'utilisateur dans la saisi des noms d'objet, de fonction, de variable, et même des arguments de fonction.

[Raccourcis clavier]{.div_voc_title}

RStudio propose de nombreux raccourcis clavier intéressants, exemple :

-   {{< kbd Alt >}} + {{< kbd - >}} renvoie l’opérateur d’assignation accompagné d’un espace avant et un espace après (\<-)\

-   {{< kbd Ctrl >}} + {{< kbd Enter >}} exécute le code écrit dans la fenêtre d’édition (script)

-   {{< kbd Ctrl >}} + {{< kbd 1 >}} et {{< kbd Ctrl >}} + {{< kbd 2 >}} permettent de passer de la console à l’éditeur de code et vice versa\

-   {{< kbd shift >}} + {{< kbd Alt >}} + {{< kbd k >}} pour accéder à l'ensemble des raccourcis.
:::

## Paramètres généraux

Pour éviter des problèmes d'encodage des scripts ou le chargement incessant de données à chaque nouvelle instance de Rstudio, **il est nécessaire de modifier certains paramètres globaux**. Pour cela, cliquez sur "*tools*" puis sur "*Global Options*" pour ouvrir la fenêtre des paramètre généraux de Rstudio.

Dans un premier temps, **décochez les options de restauration et de sauvegarde de données** à l'ouverture et à la fermeture de session :

![](figures/restore_rdata.png)

Puis, dans l'onglet "*code*" et le sous-onglet "*saving*", **paramétrez l'encodage en UTF-8** pour que les scripts crées s'affichent correctement en cas d'ouverture dans un autres systèmes d'exploitation :

![](figures/encodage.png)

## Les projets {#les-projets}

Cette fonctionnalité permet d'organiser son travail en différents projets. L’idée principale est de réunir tous les fichiers relatifs à un même projet (quelque soit leur format) dans un répertoire dédié. **Le menu** "***Project***" **est accessible via une icône dédiée située tout en haut à droite** :

![](figures/project.PNG)

Dans le menu "***Project***", sélectionnez l’option "***New project***" :

![](figures/nproj.PNG)

Dans un nouveau répertoire, créez un projet vide. Indiquez le nom de votre projet, qui sera également le nom du répertoire créé pour stocker les données du projet. Puis, indiquez le répertoire parent, dans lequel votre projet sera créé :

![](figures/nproj2.PNG)

## Les objets

Tout ce qui est créé et manipulé sous R est un objet. Ces objets permettent de stocker et de structurer les données. **Les objets peuvent stocker différents types de données**. Voici les principaux :

-   **La chaîne de caractères** (*string*) : Il s'agit d'une suite ordonnée de caractères, mise **entre guillemets**. Ex : *"Ma chaîne de caractères"* ou "*234*"

-   **Nombre entier** (*integer*) : Il s'agit d'un nombre sans décimale (sans virgule). Ex : *347*

-   **Nombre réel** (*numeric*) : Il s'agit d'un nombre décimal. Ex : *86.6*

-   **Valeur logique ou booléenne** (*logical*) : Une variable booléenne est une variable qui ne prend que deux valeurs : *TRUE* (vrai) et *FALSE* (faux) ou *0* et *1*

### Créer un objet

Un objet peut être créé avec l'opérateur « assigner » (`<-`), une flèche composée du signe inférieur (`<`) accolée à un tiret (`-`). Si l'objet existe déjà, sa valeur précédente est remplacée par la nouvelle. La valeur renvoyée peut être le résultat d'une opération et/ou d'une fonction :

```{r}
n <- "chaîne de caractères"

n

n <- 15 + 9

n

```

**On peut également écrire une expression sans assigner son résultat ou sa valeur à un objet**, le résultat est alors affiché à l'écran mais n'est pas stocké dans un objet en mémoire :

```{r}

(10 + 2) * 5

# Pour enregister le résultat en mémoire, on l'assigne dans un objet, ex :
Mon_objet <- (10 + 2) * 5

```

### La fonction

Le logiciel R dispose de fonctions préprogrammées appelées **fonctions primitives ou basiques** et regroupées dans le package **base** qui est automatiquement chargé. Pour connaître toutes les fonctions primitives, utilisez la fonction [library(help = "base")]{.fonction}:

```{r}

library(help = "base")

# Quelques exemples...

# class()           Connaitre la classe de données d'un élément
# as.character()    Assigner la class 'caractere' à un élement
# is.numeric()      Tester si un élément est numéric (réponse TRUE ou FALSE) 
# paste()           Coller des chaine de caractère
# unlist()         permet de transformer une liste en vecteur

```

**Pour utiliser une fonction, il suffit d'écrire son nom, puis de spécifier des arguments entre parenthèse**.

Exemple de fonctions permettant d'assigner ou de modifier la classe d'un objet :

```{r, eval=FALSE}

# Les différentes fonctions permettant de convertir la classe de l'objet 'mon_objet' :
as.vector(x='mon_objet')
as.data.frame(x='mon_objet')
as.matrix(x='mon_objet')
as.array(x='mon_objet')
as.list(x='mon_objet')
as.factor(x='mon_objet')

```

```{r, eval=TRUE}

# Exemple
mon_objet <- "20345"

class(mon_objet)

mon_objet <- as.numeric(mon_objet)

class(mon_objet)

```

Une fonction est paramétrable, ajustable à l'aide d'**arguments**. Très souvent, les arguments d'une fonction sont prédéfinis. Il est donc important de **se renseigner sur les différents arguments d'une fonction et ses valeurs paramétrées par défaut**. Cependant, certains arguments n'ont pas toujours de valeur prédéfinie et doivent être renseignés.

Exemple avec la fonction [mean()]{.fonction} :

```{r, eval=TRUE}

notes <- c(11,13,15,17,10,8,14,13,12,15,19,NA)

# Il est évidemment obligatoire de spécifier le vecteur de valeurs sur lequel on calcul une moyenne !
mean(notes)

```

La fonction [mean()]{.fonction} retourne NA car la série statistique présente une valeur manquante (NA pour *Not Available*). **L’argument na.rm (= FALSE par défaut) permet de ne pas prendre en compte les valeurs manquantes** :

```{r, eval=TRUE}

# na.rm (= FALSE par défault) permet de prendre en compte ou non les valeurs NA
mean(notes, na.rm = TRUE)

```

::: {.callout-tip title="Remarque"}
En plus des valeurs *NA*, on trouve aussi des valeurs notées **NULL** ou encore des valeurs vides. Attention à ne pas confondre les valeurs NA avec les valeurs **NaN** *(Not A Number)*. Ces valeurs peuvent apparaître à la suite d'erreurs d'encodage, de division par 0 ou bien d'oubli dans la complétion d'un vecteur.
:::

L'utilisateur a également la possibilité de définir ses propres fonctions. Une fonction est mise dans une variable contenant un bloc d'instructions introduit par la commande [function()]{.fonction}. La syntaxe générale est :

```{r}

nom_de_fonction <- function(arguments) { instructions }

```

Exemple :

```{r}

# Ecriture une fonction
carre <- function(x) {
  y <- x*x
  return(y)
}

# Pour afficher le code source d'une fonction (non primitive), 
# écrire son nom sans parenthèse :
carre

# Utiliser une fonction :
# fonction(argument1=... , argument2=..., argument3=..., ... )

# Exemple :
# carre(x=3) ou plus simplement :
carre(3)

```

En plus des fonction primitives, des fonctions que vous pouvez vous même créer, **il est très simple d'utiliser des fonctions mises à disposition par l'intermédiaire de packages**. Pour cela, vous devez d'abord **installer le package et charger la library** :

```{r, eval=FALSE}

# Installation du package
install.packages("foreign")

# Chargement de la library
library(foreign)

# Utilisation de la fonction read.dbf() de la library "foreign"
# L'argument as.is permet de convertir ou non les vecteurs en facteurs
read.dbf("D:/users/geographie/Documents/nom_fichier.dbf", as.is = FALSE)

```

### Le vecteur

**Un vecteur permet de regrouper des éléments d'une même classe**.

```{r }

# Joindre des éléments dans un vecteur
mon_vecteur <- c(1,2,3,4,5,6,7,8,9)
mon_vecteur <- c("A","B","C","D","E")
mon_vecteur <- c("nom", "prenom", 10, 20.78, TRUE)
mon_vecteur

# Créer un séquence de nombres entiers
mon_vecteur <- c(1:7)
mon_vecteur

# Ajouter un élément à un vecteur
mon_vecteur_new <- c(mon_vecteur, "Un Élément Supplémentaire")

# Interroger les éléments d'un vecteur -> mon_vecteur[element]
# Elément 2
mon_vecteur[2]
# Eléments 2 à 4
mon_vecteur[2:4]
# Eléments 2 et 5
mon_vecteur[c(2,5)]


```

### Le data frame

Un data frame est utilisé pour stocker une table de données. Il s'agit d'une liste de vecteurs de même longueur.

```{r}

# Construction de trois vecteurs
personne <- c('John Doe','Peter Gynn','Jolie Hope','John snow')
salaire <- as.integer(c(21000, 23400, 26800, 32700))
date <- as.Date(c('2010-11-1','2008-3-25','2007-3-14', '1678-1-23'))

# Construction du data.frame à partir de trois vecteurs de même longueur
mon_tableau <- data.frame(personne, salaire, date)
mon_tableau

# Ajouter une variable
mon_tableau$New_col_1 <- "mon_texte"
mon_tableau$New_col_2 <- c(1,2,3,4)
mon_tableau

# Interroger les éléments d'un tableau -> mon_tableau[ligne,colonne]
# Ligne 2
mon_tableau[2,]
# Colonnes 1 et 3
mon_tableau[,c(1,3)]
# Colonne 'personne'
mon_tableau$personne
# Ligne 4 & colonne 'personne' - method 1
mon_tableau[4,"personne"]
# Ligne 4 & colonne 'personne' - method 2
mon_tableau$personne[4]

```

### La liste

**Une liste est un vecteur d'objets**. Elle permet de stocker des valeurs de différents types dans un seul objet.

```{r}

ma_fonction <- function() {cat("hello")}
mon_vecteur1 <- c('John Doe','Peter Gynn','Jolie Hope','John snow')
mon_vecteur2 <- as.Date(c('2010-11-1','2008-3-25','2007-3-14', '1678-1-23'))
mon_tableau <- data.frame(mon_vecteur1, mon_vecteur2)

# Création d'une liste
ma_liste <- list(ma_fonction, mon_vecteur1, mon_vecteur2,mon_tableau)
ma_liste

# Ajouter un élément à une liste
ma_liste[[length(ma_liste) + 1]] <- "J'ajoute un objet à ma liste"


# Interroger les objets d'une liste -> ma_list[[élement]][sous element]
# Objet 1
ma_liste[5]
# Objets 2 et 3
ma_liste[c(2,3)]
# Tous les objets sauf le 1 et le 4
ma_liste[-c(1,4)] 
# Elément 2 de l'objet 3
ma_liste[[3]][2]


```

### La matrice

Une matrice est un **tableau d'objet de même type, à double entrée**. Le remplissage s'effectue en colonnes.

```{r}

ma_matrice <- matrix(c(1:16), nrow=4, ncol=4) 

# On navigue dans une matrice de la même façon que dans un data frame -> ma_matrice[ligne, colonne]
ma_matrice[4,3]

```

De nombreuses opérations et **fonctions** primitives sont applicables à cet objet. Quelques exemples :

```{r}

# Multiplication de matrice, élément par élément.
ma_matrice * ma_matrice 
# Transposer la matrice
t(ma_matrice)
# Sélectionner la diagonale
diag(ma_matrice)
# Moyennes des lignes
rowMeans(ma_matrice)
# Sommes des colonnes
colSums(ma_matrice)

```

### Le Simple Feature data frame

**L'objet [sf]{.package} est en quelque sorte une table de données géographiques**. Il permet de gérer de l'information spatiale. Il s'agit tout simplement d'un dataframe qui stocke également des géométries (coordonnées).

Un objet sf se présente comme un tableau de données data.frame, donc comme une table attributaire, à laquelle on ajoute une colonne `geom` ou "geometry spécifique", de classe ***sfc*** (simple feature column) contenant les géométries (simple feature geometry). Chaque ligne, chaque individu est appelé simple feature.

![](figures/sfeature.png){width="60%"}

Dans l’écosystème R, le data.frame est conçu comme une structure de vecteurs. On peut donc effectuer sur les objets sf les même manipulations que l’on fait sur les vecteurs et tableaux dans R.

La colonne contenant les géométries peut quant à elle prendre les types de géométrie traditionnels pris en charge par les [GeoJSON](https://www.rfc-editor.org/rfc/rfc7946) :

| type | description |
|--------------------|----------------------------------------------------|
| `POINT` | géométrie à zéro dimension contenant un seul point |
| `LINESTRING` | séquence de points reliés par des morceaux de lignes droites qui ne se coupent pas entre elles ; géométrie unidimensionnelle |
| `POLYGON` | Géométrie à aire positive (bidimensionnelle) ; une séquence de points forme un anneau fermé, non auto-intersecté ; le premier anneau désigne l'anneau extérieur, zéro ou plusieurs anneaux suivants désignent des trous dans cet anneau extérieur |
| `MULTIPOINT` | ensemble de points ; un MULTIPOINT est simple si aucun des points du MULTIPOINT n'est égal. |
| `MULTILINESTRING` | ensemble de `LINESTRING` |
| `MULTIPOLYGON` | ensemble de `POLYGON` |
| `GEOMETRYCOLLECTION` | ensemble de géométries de tout type sauf `GEOMETRYCOLLECTION` |

Cette colonne se prête aux géotraitements typiques d'un SIG comme le buffer, l'intersection ou l'agrégation.

```{r}

# Création d'un vecteur de nombre (1 à 10)
ID <- seq(1:10)
# Création d'un vecteur de lettres (a à j)
name <- letters[1:10]
latitude <- c(48.84905, 48.85217, 48.83349, 48.86528, 48.86409, 48.85176, 48.85207, 48.88334, 48.85758, 48.87391)
longitude <- c(2.331454, 2.347332, 2.318518, 2.371150, 2.356515, 2.299024, 2.358712, 2.333936, 2.352751, 2.343179)

mes_donnees <- data.frame(ID, name, latitude, longitude)

library(sf)
mes_donnees_SF <- st_as_sf(mes_donnees, coords = c("longitude", "latitude"), crs = 4326, agr = "constant")
mes_donnees_SF

# Interroger un objet sf
# Fonctionne comme pour un data frame pour les différentes variables
# Colonne 'ID'
mes_donnees_SF$ID
# Colonne ID, ligne 3
mes_donnees_SF$name[3]
# Geometrie de l'entités 3
mes_donnees_SF$geometry[3]

# Affichage des geometries avec plot()
plot(st_geometry(mes_donnees_SF))

```

### Le facteur

**Un facteur (factor) est un vecteur contenant uniquement certaines valeurs prédéfinies**. Les valeurs pré-définies sont appelées des **levels**.

```{r}


my_factor <- sample(x = c("North", "East", "South", "West"), size = 13, replace = TRUE)
my_factor

# Les éléments sont considérés comme caractère
class(my_factor)

# Conversion en facteur
my_factor <- factor(my_factor)

# Comment se structure le facteur
str(my_factor)

# Interroger les éléments d'un factor -> factor[element]

# levels() permet d'obtenir la liste des valeurs :
levels(my_factor)

# Compte du nombre d'éléments par level
summary(my_factor)

# Elément 8
my_factor[8]

# Eléments 7 à 13, avec uniquement les levels présents
my_factor[7:13, drop=TRUE]

```

## Les opérateurs

### Arithmétiques

```{r}

# Addition
5 + 5

# Soustraction
5 - 5

# Division
5 / 5

# Multiplication
5 * 5

# Exposant
5^5

```

### Relationnel

```{r, eval=FALSE}

  <    # inférieur à 
  >    # supérieur à 
  <=   # inférieur ou égal à 
  >=   # supérieur ou égal à 
  ==   # égal 
  !=   # différent 
  %in% # Test de présence entre deux vecteurs
  
```

```{r}

# Exemple
5 == 5
5 != 5
c(1,2,3) %in% c(2,7,5) 

```

### Logique

```{r, eval=FALSE}

  !         # Négation
  &, &&     # ET 
  |, ||     # OU inclusif
  xor(,)    # OU exclusif (retournera TRUE si l'une ou l'autre mais pas les deux sont vraies)
  is.na()   # Valeur manquante ?
  is.null() # Valeur Null ?
  is.character() # Caractère ?
  is.numeric() # Numérique ?

```

```{r}

# Exemples

# Selection dans un data frame avec plusieus conditions (ET)
mtcars[mtcars$mpg %in% c(21.0,14.3,22.8,19.2) & mtcars$hp != 123 & mtcars$wt >= 3, ]

# Selection dans un data frame avec plusieus conditions (OU)
mtcars[mtcars$mpg %in% c(21.0,14.3,22.8,19.2) | mtcars$hp != 123 | mtcars$wt >= 3, ]

# Test valeurs NA (différent de NA ?) dans la variable mtcars$mpg
!is.na(mtcars$mpg)

# Renvoie les valeurs des index correspondant à l'affirmation
mtcars$mpg[7] <- NA
!is.na(mtcars$mpg)

```

## Les packages

R fourni directement **un important nombre de fonctions pré-installées, stockées dans ce qui est appelé le [R Base Package](https://stat.ethz.ch/R-manual/R-devel/library/base/html/00Index.html%22%20onclick=%22window.open(this.href);%20return%20false;){.package}**. Il n'est pas nécessaire de les installer ou de les charger, elles sont immédiatement utilisables. À ce jour, **`r nb_function_base` fonctions sont proposées par le le R-base**.

**Les fonctions du r-base permettent d'effectuer les manipulations de données les plus classiques**. Pour effectuer des traitements plus spécifiques, il est nécessaire d'installer des packages mis à disposition par d'autres utilisateurs sur le [CRAN : The Comprehensive R Archive Network](https://cran.r-project.org/%22%20onclick=%22window.open(this.href);%20return%20false;).\
**Les packages sont des collections de fonctions**, associées à de la documentation et parfois même à des données. Le `r format(Sys.time(), '%d %b %Y')`, **`r max(test2$cum)` packages supplémentaires** sont mis à disposition sur le [CRAN](https://cran.r-project.org/%22%20onclick=%22window.open(this.href);%20return%20false;). Tous les packages disponibles sur le [CRAN](https://cran.r-project.org/%22%20onclick=%22window.open(this.href);%20return%20false;) ont été contrôlés. Leur fonctionnement technique (uniquement) est garanti, car il s'agit d'un dépôt officiel de packages.

Il est également possible d'installer des packages en cours de développement et mise à disposition sur un GIT ou d'installer un package stocké en `.tar`ou `.gz` sur votre machine.

Installer un package en langage R :

```{r eval=FALSE}

# Pour les packages disponibles sur le CRAN :
install.packages("mapsf") # Installer un package
update.packages("mapsf")  # Mettre à jour un package

# Pour obtenir le chemin de la librairie contenant les packages installés
.libPaths() 
# Pour voir tous les packages installés
library()   

# Pour les packages stockés en local et compressés en tar.gz. Ex (NOT RUN) :
install.packages("C:\\RJSONIO_0.2-3.tar.gz", repos = NULL, type="source")

# Pour les packages en cours de développement sur un GIT,
# il est nécessaire d'installer et de charger le package remotes :
install.packages("remotes")
library(remotes)
install_github("riatelab/MTA")
```

Une fois installé, **un package doit être chargé à chaque nouvelle session de R pour être utilisé**. A chaque package est systématiquement associée de la documentation permettant de comprendre son contenu et aider à sa prise en main.

```{r,eval=FALSE}

# Charger un package pour en utiliser ses fonctions
library(mapsf)  

# Utiliser directement une fonction d'un package précis
mapsf::mf_map()

# Pour charger des données implémentées dans un package
data(Nom_objet)

```

**L'interface RStudio permet également l'installation et le chargement manuel des packages** :

![](figures/package.PNG)

**Pour supprimer un package**, vous pouvez utiliser la fonction suivante :

```{r,eval=FALSE}

remove.packages("mapsf")

```

## Aide et documentation

Il y a plusieurs façons d'obtenir de l'aide avec R studio. **Vous pouvez utiliser l'onglet d'aide proposé par Rstudio** et accéder à la documentation d'une fonction :

![](figures/onglet_aide.png)

Il est possible d'**obtenir de la documentation en utilisant des fonctions**, Ex :

```{r, eval=TRUE, include=FALSE}
library(mapsf)  
```

```{r,eval=FALSE}

# Documentation des packages
help("mapsf") 

# Accèder à la documentation d'une fonction
?mf_map

# Accèder à une vignette (falcutatif) de package
vignette(topic = "mapsf", package = "mapsf")

# Accèder à une cheatsheet (falcutatif) de package
vignette(topic = "cheatsheet", package = "cartography") 

# Chercher documentation par mot clé
help.search("Map")

```

Exemple de la *cheatsheet* (antisèche) du package [sf]{.package} (page 1/2) :

![](figures/cheatsheet.png)

**Ne négligez pas le service d’auto-complétion proposé par RStudio**. C'est un véritable assistant de programmation. Il permet par exemple de s'assurer du bon orthographe d'un objet ou d'une fonction ou de connaître les différents arguments possibles d'une fonction. Pour cela **il suffit d'utiliser la touche `tab` lors de la saisie**. RStudio vous proposera alors les possibilités qui s'offrent à vous.

![](figures/CodeCompletion.png)

Enfin, **internet est une ressource documentaire très riche pour R**. Vous y trouverez toujours une réponse à vos questions, et presque toujours en français !

## Règles de codage

Les [**règles de codage**](https://fr.wikipedia.org/wiki/R%C3%A8gles_de_codage) permettent d'écrire un code plus clair et plus lisible pour soi et pour les autres. Vous pourrez trouver plusieurs propositions de *coding style* car il n'existe pas de style officiel pour le logiciel R. Quelque soit le style choisi l'idée est de conserver le même tout au long d'un programme.\
Voir par exemple :

-   [Advanced R - Style guide](http://adv-r.had.co.nz/Style.html)\
-   [Google's R Style Guide](https://google.github.io/styleguide/Rguide.xml)\
-   [R Style Guide](http://jef.works/R-style-guide/)

**Trois règles font tout de même l'unanimité :**

-   Eviter les lignes de plus de 80 caractères.\
-   Utiliser un espace avant et après les opérateurs :

```{r, eval=FALSE}

# Préférez
x  <-  12
# à
x<-12

# Préférez
average <- mean(feet / 12 + inches,
                na.rm = TRUE)
# à
average<-mean(feet/12+inches,na.rm=TRUE)

```

-   Eviter les lignes avec plus d'une opération :

```{r, eval=FALSE}

### Il est possible d'écrire plusieurs opération sur une me ligne, en les séparant d'un ;
# Exemple
notes <- c(4,2,8,6,5,9,3,2,5,6); mean(notes); sd(notes)

# Mais cela est à proscrire.
# Pour plus de visibilité, préférez :
notes <- c(4,2,8,6,5,9,3,2,5,6)

mean(notes)

sd(notes)

```

**L'intégration de commentaire dans le code est également une pratique appréciée**. Pour cela, **insérer un \# en début de ligne**.

```{r, eval=FALSE}

# Les caractères suivants seront considérés comme du commentaire
# Vous pouvez écrire ce que vous voulez, mais toujours précédé d'un #


# une chaîne de 5# (#####) permet de créer de bloc de code dépliable :

###### 
mean(c(1,7,3,2,8,9,2,3))

```

**Ces règles de codages sont à appliquer durant les exercices !**

# Prise en main

::: exercice
A)  **Créez un nouveau projet** à l'emplacement de votre choix ([cf. *Les projets*](#les-projets)).\
B)  **Téléchargez** [**ces données**](https://github.com/HuguesPecout/Initiation_R_stats/raw/main/data.zip) de recensement **(INSEE, 2016)** pour les communes de la Martinique en 2011 et 2016, associées à une couche géographique **(IGN - BD ADMIN EXPRESS, 2016)**.
C)  **Décompressez l'archive** à la racine de votre répertoire projet.\
D)  **Créez un nouveau ficher .R** (*File \> New File \> R Script*), puis **enregistrez-le**. Vous pourrez ainsi écrire du code R dans ce fichier, et sauvegarder votre travail.
:::

## Import/export de données

De nombreuses [fonctions]{.fonction} (primitives ou non) peuvent être utilisées pour importer et exporter des données de différents formats.

### Import

```{r,eval=FALSE}

### IMPORTER
read.table() # Importer une table (format multiple)
read.csv()   # Fichier csv
read.xlsx()  # Fichier Excel = library(xlsx) 
read_sas()   # Fichier sas = library(haven)
read.dbf()   # Fichier dbf = library(foreign)
st_read()    # Données géographiques (shape, GeoJson...) = library(sf)

```

Pour que l'import soit correct, il est souvent nécessaire de renseigner un certain nombre d'arguments, comme par exemple :

**header** = valeur logique qui indique si la première ligne du fichier importé contient les noms des variables. **sep** = Indique le séparateur de champ du fichier. **stringsAsFactor** = Le données de type caractère sont transformées (par défaut) en facteur. **Encoding** = Indique l'encodage utilisé pour les chaînes de caractères.

```{r,eval=FALSE}

# Import d'un fichier 
# not run
Mon_Objet <- read.table("/data/user/documents/mes.donnes.csv"), header=TRUE, sep=",", 
stringsAsFactors=FALSE, encoding="UTF-8")

```

Il est également possible de télécharger un fichier en ligne, avec la fonction suivante :

```{r,eval=FALSE}

# Télécharger un fichier
download.file()

# Décompressez une archive
?unzip()

```

### Export

```{r,eval=FALSE}

### EXPORTER

## Table de données
write.table(Mon_Objet, "c:/mydata.txt", sep="\t") 

# format csv
write.csv(Mon_Objet, file = "MyData.csv")

# format Excel -> library(xlsx)
write.xlsx(Mon_Objet, "c:/mydata.xlsx")

# format sas, spss... -> library(foreign)
write.foreign(Mon_Objet, "c:/mydata.txt", "c:/mydata.sas",   package="SAS")
write.foreign(Mon_Objet, "c:/mydata.txt", "c:/mydata.sps",   package="SPSS")

# format shape
st_write()
```

### Image

Les représentations graphiques peuvent également être exportées sous différents formats :

```{r,eval=FALSE}

## Figures plot() 
# format jpeg
jpeg()
# format png
png()
# format pdf
pdf()

# Exemple d'enregistrement d'une figure :
jpeg('rplot.jpg')
plot(runif(10, 1, 100),runif(10, 1, 100))
dev.off()

```

### Exercice

::: exercice
**Importez le fichier** *INSEE_COM_972.csv*, et **stockez-le dans un objet**.

```{r eval=FALSE}

# Fonctions possibles
read.csv()
read.table()

# Quelques arguments utiles...
header=TRUE
sep=","
stringsAsFactors=FALSE

```
:::

## Interroger un objet

Pour les exemples ci-dessous, l'objet dataframe *mtcars* est utilisé. Il s'agit d'un exemple de data frame implanté dans R.

```{r, eval=FALSE}

# Pour visualiser le data frame
View(mtcars)

```

```{r}

# Pour un aperçu rapide dans la console
str(mtcars)

```

Ces deux fonctions sont directement accessibles en clic-bouton depuis l'interface Rstudio. Il suffit de cliquer sur l'objet dans l'onglet *Environnement* situé en haut à droite de l'IDE Rstudio (équivalent à [View()]{.fonction}) ou sur la flèche à gauche du nom de l'objet (équivalent à [str()]{.fonction}).

![](figures/mtcars.png)

```{r}
# Visualiser les premiers éléments (6 par défaut) de l'objet
head(mtcars)
# Visualiser les derniers éléments (6 par défaut) de l'objet
tail(mtcars)
# Statistiques basiques
summary(mtcars)
# classe/type des éléments/objets
class(mtcars)
# Longueur = nombre d'éléments de l'objet
length(mtcars)

# Pour les objets à plusieurs dimensions :
# Noms des colonnes
colnames(mtcars)
# Noms des lignes
row.names(mtcars)
# Dimension de l'objet
dim(mtcars)
# Nombre de colonnes
ncol(mtcars)
# Nombre de lignes
nrow(mtcars)

```

### Exercice

::: exercice
**Visualisez et interrogez votre data frame**, en ligne de code ET depuis l'interface RStudio.

```{r eval=FALSE}

# Fonctions possibles :
View()
head()
dim()
str()
summary()
class()
colnames()
...

```

**Vérifiez le type de données stocké pour chaque variable**. Si nécessaire, **corrigez la classe de données des variables** '*CODGEO*, '*DEP*', '*REG*', '*CATAEU2010*' **de votre data frame comportant les données de recensement**. **N'oubliez pas d'assigner le résultat de la conversion :**

```{r eval=FALSE}

# Convertissez le type de données d'une variable
Mon_Objet$xxxx <- as.character(Mon_Objet$xxxx)

```

**Créez une nouvelle variable contenant la part de la population âgée de 0 à 14 ans en 2016** (P16_POP0014 / P16_POP \* 100) :

```{r eval=FALSE}

# Assigner les valeur dans une nouvelle colonne
mon_tableau$new_var <- ... ?

```
:::

## Sélection par attributs

Comme pour toutes les opérations dans R, **il existe plusieurs solutions**. Exemple :

### Méthode 1 - Base

```{r}

# df[ligne, colonne]
mtcars[mtcars$cyl==4 & mtcars$wt > 3,  c(1:7) ]

```

### Méthode 2 - Fonction primitive

```{r}

# subset()
subset(mtcars, cyl==4 & mtcars$wt > 3, select=c(1:7))

```

### Méthode 3 - Package dplyr

```{r}

# filter() du package 'dplyr'
library(dplyr)
mtcars %>% 
  select(1:6) %>%
  filter(cyl==4, wt > 3)


```

### Exercice

::: exercice
**Sélectionnez les communes isolées hors influence des pôles** (CATAEU2010 == 400) **de plus de 2000 habitants** en 2016 (P16_POP).

```{r eval=FALSE}

# Une de solution possible :
tableau[tableau$CATAEU2010==400 & ... , ]

```
:::

**Enregistrez le résultat de votre sélection par attribut dans un nouvel objet**.

## Jointure

La jointure, opération classique en géomatique, est très facile à réaliser avec R.

```{r}

# Construction de deux dataframe avec un identifiant commun
ID <- c("1", "2", "3", "4")
Prenom <- c('John','Peter','Jolie','John')
Nom <- c('Doe','Gynn','Hope','snow')

# Dans la console, la chaîne de caractère "snow" correspond aussi à une couleur

# Dataframe 1
mon_tab_1 <- data.frame(ID, Prenom)

# Dataframe 2
mon_tab_2 <- data.frame(ID, Nom)

# Jointure des deux objets avec la fonction merge()
merge(mon_tab_1, mon_tab_2, by="ID")
```

**Cela fonctionne également entre un objet [sf]{.package} (couche géographique) et un dataframe**.

### Exercice

::: exercice
**Chargez la couche géographique** *martinique.shp*, et **stockez-le dans un objet**.

```{r eval=FALSE}

# Utilisez la fonction du package sf :
st_read()

```

**Réalisez une jointure entre la couche géographique et votre tableau de données**, en assignant le résultat dans un nouvel objet. Utilisez le code INSEE des communes pour la jointure

```{r eval=FALSE}

# Pour réaliser une jointure, utilisez la fonction :
merge()

# Préciser la variable de jointure pour les deux objets avec les arguments :
by.x=
by.y=

```
:::

## Regroupement

**Le regroupement de ligne est une opération récurrente en gestion de base de données**. Plusieurs solutions sont possibles :

### Méthode 1 - Fonction primitive

```{r}

# Regroupement des lignes en fonction des valeurs des variables "disp" et "cyl"
# + somme des valeurs de la variable "vs"
aggregate(data = mtcars, disp ~ cyl + vs, sum)

```

### Méthode 2 - Package tidyverse

```{r}

# Package dplyr
# Permet facilement le calcul sur plusieurs champs
library(dplyr)
mtcars %>% 
  group_by(cyl, vs) %>% 
  summarise(sum_disp=sum(disp), 
            moy_hp=mean(hp), 
            nb_element=length(cyl))

```

### Méthode 2 - Package data.table

```{r}

library(data.table)
mtcars2 <- data.table(mtcars)
mtcars2[, .( sum_disp=sum(disp), moy_hp=mean(hp), nb_element=length(cyl) ), by=list(cyl, vs)]

```

::: {.callout-tip title="Remarque"}
Le package [data.table]{.package} est plutôt utilisé pour les gros volumes de données.
:::

### Exercice

::: exercice
**Commencez par calculer la somme de la population totale de la Martinique** à l'aide la fonction suivante :

```{r eval=FALSE}

sum()

```

**Puis calculez la somme de la population 2016 pour chaque catégorie de commune du zonage en aire urbaine de 2010** (CATAEU2010):

```{r eval=FALSE}

# Une solution
aggregate()

# Nom des variables à utiliser
P16_POP ~ CATAEU2010

```
:::

## Trier les données

Deux fonctions primitives sont à connaître pour trier des valeurs :

```{r}

# Fonction sort()
my_vector <- c(7,9,4,5,2,3,6,1)
sort(my_vector)

# Fonction order()
mtcars[order(mtcars$cyl, mtcars$disp, decreasing = TRUE), ]


```

**Vous devez assigner le résultat dans un objet pour enregistrer le nouvel ordre !**

### Exercice

::: exercice
**Triez votre tableau de données en fonction de la population de 2016** (croissant) :

```{r eval=FALSE}

order()

```
:::

## Test conditionnel

**Un test conditionnel permet d'exécuter une portion de code ou non en fonction du résultat de variables booléennes**.

```{r, eval=FALSE}

# Test simple
if (condition){action}

# Test avec deux solutions
if (condition){
  action1
} else {
  action2
}

```

```{r}
# Exemple
x <- "chaîneDeCaractères"
x <- TRUE
x <- 12

if (is.character(x)){
  
  print("x est une chaîne de caractères")
  
} else {
  
  if (is.numeric(x)) {
    
    print("x est numérique") 
    
  } else {
    
    print("x est bizarre !")
    
  }
}

```

### Exercice

::: exercice
**Testez si votre tableau de données est bien un objet dataframe**, et **affichez le résultat dans la console** avec la fonction [print()]{.fonction} :

```{r eval=FALSE}

if (is.data.frame()) { print() } else { print() }

```
:::

## Boucle itérative

**Une boucle est une série d'instructions exécutées jusqu'à ce qu'un résultat particulier soit obtenu ou qu'une condition pré-déterminée soit remplie**. Les boucles permettent de ré-utiliser des séries d'instructions et permettent ainsi de limiter le nombre d'instructions.

```{r, eval=FALSE}

# Structure d'une boucle
for (variable in vecteur) {
  instruction
}

```

```{r}

# Exemple
for (i in 1:5) {
  print(paste0("Passage n°", i))
}

```

## Fonctions apply

L'utilisation d'une boucle est très fréquente en traitement de données. Une boucle peut permettre d'effectuer des traitements sur des objets de structure multidimensionnelle (data frame, matrice, array, sf...). Mais pour cela, la boucle for n'est pas la technique optimale. Les concepteurs de R ont développé des fonctions spécialement prévues à cet effet.

```{r}

# Appliquer une fonction sur les lignes :
apply(mtcars,1,mean)

# Appliquer une fonction sur les colonnes :
apply(mtcars,2,sum)

# Appliquer une fonction sur chaque item (sortie vector) :
sapply(mtcars, function(x) x/100)


# Appliquer une fonction sur chaque item (sortie list)
Resultat_lapply <- lapply(mtcars, function(x) x/100)
Resultat_lapply[1:3]

```

## Chaîne de caractères

De nombreuses fonctions primitives existent pour gérer les chaînes de caractères. Quelques exemples :

### Concaténer

```{r}

# Concaténation de chaîne de caractère, AVEC séparateur
paste("Champions", "du", "monde", sep=" ")

# Concaténation de chaîne de caractère, SANS séparateur
paste0("Champions", "du", "monde")

```

### Gérer la casse

```{r, eval=TRUE}

# Gérer la casse
text <- "champion Du MONDEEEEEE !"

```

```{r, eval=TRUE}
# tout en minuscule
tolower(text)
```

```{r, eval=TRUE}
# tout en majuscule
toupper(text)

```

### Compter

```{r, eval=TRUE}

# Nombre de caractères
nchar(text)

```

### Modifier

```{r, eval=TRUE}

# Scinder une chaîne en fonction d'un caractère
strsplit(text, split = " ", fixed = TRUE)

```

```{r, eval=TRUE}

# Remplacer un (ou plusieurs) caractère(s) par un autre
gsub("ion", "ionne", text)

```

### Package stringr

Si vous souhaitez réaliser des traitements complexes sur des chaînes de caractères, vous pouvez utiliser la **librairie de référence** [stringr]{.package} qui vous permettra de réaliser des opérations plus complexes. Exemples :

```{r, eval=FALSE}

library(stringr)

# Détecter la présence d'un caractère ou d'une chaîne
# Renvoie TRUE ou FALSE
str_detect(text,  "E")

# Position de la première occurrence d'un caractère ou d'une chaîne 
# Renvoie la position du premier et dernier caractère
str_locate(text, "pi")

# Toutes les positions d'un caractère ou d'une chaîne
# Renvoie toutes les positions
str_locate_all(text, "E")

# Extraire un segment de chaîne de caractère
# Renvoie la chaîne de caractère extraite
str_sub(text,  5, 9)

# Suppression des espaces en début et fin de chaîne de caractère
str_trim("  abc    ")

```

### Regex

Il est possible de combiner l'**utilisation des expressions régulières avec toutes ces fonctions**.

**Les expressions régulières**, ou plus communément REGEX (contraction de *regular expression*) **permettent de représenter des modèles de chaînes de caractères. Ce sont des outils très puissants et très utilisés : on peut les retrouver dans de nombreux langages comme le PHP, MySQL, Javascript...** Si cet outil est très puissant, il est relativement difficile à appréhender au début car les expressions régulières peuvent prendre des formes complexe à interpréter. Ex :

```{r}

# EXEMPLE d'utilisation d'expression régulière (regex)

# Création d'une vecteur d'adresse mail
# Avec des adresses mail, parfois mal orthographiées
emails_list <- c("louis.laurian@cnrs.fr",
                 "elina.marveaux@cnrs.fr",
                 "louis@gmail", 
                 "blabla.com", 
                 "louis.laurian@riate.fr")


# Expression regex qui répond aux adresses email
regex <- "\\<[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\>"


# Détection des emails corrects présentes dans ma liste d'email
grep(regex, emails_list, ignore.case=TRUE)


```

### Exercice

::: exercice
**Créez une nouvelle colonne** "***NOM***" dans votre objet [sf]{.package}, pour y stocker **le nom des communes en lettre CAPITALE**.

```{r eval=FALSE}

# Fonction à utiliser :
toupper()

```
:::

## Représentations graphiques

### Fonction primitives

Plusieurs fonctions primitives permettent de réaliser des graphiques :

```{r, eval=FALSE}

plot()
hist()
barplot()
boxplot()
pie()
lines()
abline()
legend()

```

```{r}

# Exemple
hist(mtcars$mpg, 
     breaks=12, 
     col="red",
     xlab= "mpg",
     ylab = "Fréquence",
     main = "Distribution de la série statistique 'mpg'")

```

Toute **une série d'arguments permet d'ajuster les représentations**, exemple :

-   **axes** : Afficher ou non les axes (TRUE ou FALSE)\
-   **log** : Mettre les axes à l’échelle logarithmique ("x", "y", "xy")\
-   **type** : Argument qui contrôle le type d'axe produit ("p"= points, "l" = ligne, "o" = point relier par ligne...)\
-   ...

**Plusieurs éléments peuvent être superposés en utilisant l'argument** "***add =TRUE***"), ex :\
- [text()]{.fonction} : Ajouter du texte\
- [legend()]{.fonction} : Ajouter un légende\
- [abline()]{.fonction} : Ajouter une ligne\
- [axis()]{.fonction} : Ajouter un axe\
- ...

**Il est possible d'afficher plusieurs graphiques en même temps**, à l'aide de la fonction [par()]{.fonction}. Ex :

```{r}

# Division de la fenêtre graphique en 2 lignes et 2 colonnes
par(mfrow=c(2,2))

# Création de 4 différents graphiques
plot(mtcars$wt, mtcars$mpg, main="Graph 1")
plot(mtcars$wt, mtcars$disp, main="Graph 2")
hist(mtcars$wt, main="Graph 3")
boxplot(mtcars$wt, main="Graph 4")

```

### Plot(sf)

La fonction [plot()]{.fonction} permet l'affichage d'un objet [sf]{.package} (couche géographique) dans la fenêtre graphique.

```{r}

library(mapsf)

# Utilisation d'un objet sf stocké dans le package mapsf
mtq <- mf_get_mtq()

# Affichage de l'objet sf
plot(mtq)
```

Attention, le fonction [plot()]{.fonction} réalise par défaut une représentation pour chaque variable de l'objet [sf]{.package}.\
**Pour afficher uniquement la géométrie, il est nécessaire d'utiliser la fonction** [st_geometry()]{.fonction} du package [sf]{.package} :

```{r}

library(sf)

# Affichage de la géométrie d'un objet sf
plot(st_geometry(mtq))

```

Pour **représenter les valeurs d'une variable de votre objet [sf]{.package}**, utilisez la syntaxe suivante :

```{r}

# Représentation visuelle
plot(mtq["POP"])

```

**Attention, ceci n'est pas une carte ! A n'utiliser que pour explorer les données.**

### ggplot2

Il existe de **très nombreux** packages **pour réaliser des représentations graphiques** (point fort du langage R).

**Le plus célèbre est** [ggplot2]{.package}. Il permet de réaliser de très nombreux types de représentation graphique. Ce package est développé par Hadley Wickham (Rstudio) et **fonctionne avec un syntaxe particulière basée sur la** ***grammaire des graphiques***, théorisée par **Leland Wilkinson**. Exemple :

```{r}

library(ggplot2)

# Exemple : Density plots
ggplot(mpg, aes(cty)) +
  geom_density(aes(fill=factor(cyl)), alpha=0.8) + 
  labs(title="Density plot", 
       subtitle="City Mileage Grouped by Number of cylinders",
       caption="Source: data R mtcars",
       x="City Mileage",
       fill="# Cylinders")

```

### Exercice

::: exercice
**Construisez un histogramme de la variable** '***C16_POP15P_CS7***' (nombre de retraités) .

```{r eval=FALSE}

# Fonction à utiliser :
hist()

```

**Représentez les valeurs de cette variable en aplat de couleur sur la géométrie de votre objet [sf]{.package}**.

```{r eval=FALSE}

# Fonction à utiliser :
plot()

```
:::

## Sauvegarder des objets

Il est possible de supprimer tous les objets crées en cliquant sur l'icône `r knitr::include_graphics('figures/clear.png')` dans la fenêtre de l'espace de travail. Plusieurs fonctions permettent également de gérer les objets. En voici quelques-unes :

```{r,eval=FALSE}

# lister tous les objets crées
ls()    

# Supprimer un objet, ex : rm(mon_objet)
rm()    

# Supprimer tous les objets
rm(list=ls()) 

# Sauvegarder un objet dans un fichier (format rds)
saveRDS() 

# Lire un fichier rds pour charger l'objet stocké
readRDS() 

```

Exemple pratique :

```{r,eval=FALSE}

mon_objet <- c("un", "deux", "trois")

# Sauvegarde d'un objet dans un fichier
saveRDS(mon_objet, file="Nom_du_fichier")

# Suppression de l'objet TEMPORAIRE
rm(mon_objet) 

# Lecture du fichier et assignation dans un objet
mon_objet_new <- readRDS("Nom_du_fichier") 

```

### Exercice

::: exercice
**Sauvegardez votre objet [sf]{.package} joint aux données de recensement dans le répertoire de votre projet Rstudio**.

```{r eval=FALSE}

# Fonction à utiliser :
saveRDS()

```

Puis, **supprimez tous les objets chargés dans votre environnement Rstudio**

```{r eval=FALSE}

# Fonctions à utiliser :
rm() et ls()

```

Enfin, **rechargez l'objet enregistré en dur** dans votre environnement Rstudio:

```{r eval=FALSE}

# Fonction à utiliser :
readRDS()

```
:::

## Bonus

**R est un langage très polyvalent... Voici un petit exercice pour le prouver :**

1)  **Trouvez où est mis à disposition le package** [wordler]{.package}, développé par David Smith\
2)  **Installez-le**\
3)  **Essayez-le**... Pas plus de 2-3 minutes :-) )\
4)  **Supprimez le package**

# Statistique univariée

## Vocabulaire

### Vocabulaire général

::: div_voc
[Statistique descriptive]{.div_voc_title}

Tout nombre, calculé à propos d’une population et qui contribue à décrire un aspect de cette population, est une statistique. Fréquences, médianes, quartiles, déciles, moyennes, variances, etc. sont des statistiques.\
La statistique descriptive regroupe l'ensemble des techniques pour **décrire numériquement une distribution**.

![](figures/vocabulaire.png)

[Population (*p*) et Individu (*i*)]{.div_voc_title}

Une population est un ensemble d'individus (ou unités statistiques) sur lesquels porte l'étude statistique.

[Effectif (*N* ou *n*)]{.div_voc_title}

Nombre d’individus d’une population(N) ou d’une partie quelconque de cette population(n).

$$N=\sum_{} i$$

[Variable (x) ou caractère]{.div_voc_title} Une variable est une information dont on recueille (ou observe ou mesure) la valeur sur chaque individu. On parle de variable parce que la valeur de l’information n’est pas la même d’un individu à l’autre. Une variable est quantitative (valeur numérique) ou qualitative :

**Une variable est quantitative si elle est mesurable**. Ex : Un temps.

Elle est **discrète** si elle ne prend que des valeurs isolées. Ex : un âge. Elle est **continue** si elle peut prendre toutes les valeurs comprises entre 2 nombres. Ex : une distance.

**Si une variable n'est pas mesurable, elle est dite qualitative**. Ex: Une couleur.

Elle est **ordinale** si on peut comparer/trier les modalités entre elles. Ex : Une appréciation. Elle est **binaire** si elle n'est composé que de deux modalités. Ex : oui/non. Elle est dite **nominale** dans les autres cas. Ex : Une forme.

Il faut bien distinguer la nature de la variable de son format de stockage (classe de donnée), numérique ou alphanumérique. Une variable qualitative peut aussi bien être codée avec des caractères alphanumériques qu’avec des caractères numériques (Ex : "Homme" ou 0 / "Femme" ou 1). Une variable quantitative peut être codée avec des caractères numériques aussi bien qu’avec des caractères alphanumériques : (Ex : "dix sept" ou 17 ).

![](figures/Schema_type_variable.png)

[Distribution]{.div_voc_title}

La distribution des individus selon une (ou deux) variables, est la répartition de l'effectif (*n*) des individus (*i*) par valeur ou classe de valeur.

[Fréquence (*f*) ou proportion]{.div_voc_title}

Rapport entre un effectif (*n*) particulier d’individus et l'effectif total (*N*).

$$f(n)=\frac{n}{N}$$
:::

### Valeurs centrales

::: div_voc
[Moyenne]{.div_voc_title}

Valeur uniforme que devrait présenter chaque individu d’un ensemble (population ou échantillon) pour que le total de l’ensemble soit inchangé.

$$\bar{x}=\frac{\sum{xi}}{N}$$

[Mode]{.div_voc_title}

Le mode (ou valeur dominante) est la valeur la plus représentée d'une variable quelconque dans une population donnée. Une répartition peut être uni-modale ou multimodale (bimodale, tri-modale…) si deux ou plusieurs valeurs de la variable considérée émergent également. Une distribution sans aucun mode est appelée distribution uniforme.

[Médiane, quartiles, déciles et centiles]{.div_voc_title}

Ces valeurs correspondent respectivement à une proportion de l'effectif des individus rangés par valeurs croissantes.

-   Médiane : valeur qui divise la série statistique en deux (50 %)
-   Quartiles : valeurs qui divisent la série statistique en quatre (Q1=25%, Q2=50%, Q3=75%)
-   Déciles : valeurs qui divisent la série statistique en dix (10% à 90%)
-   Centiles : valeurs qui divisent la série statistique en cent (1% à 99%)
:::

### Paramètres de dispersion

::: div_voc
[Amplitude]{.div_voc_title}

Longueur de l'intervalle entre la valeur minimum et maximum.

[Intervalle interquartile]{.div_voc_title}

Basé sur les quantiles, l’intervalle inter-quartile (Q3-Q1) est un paramètre de dispersion absolue qui correspond à l’étendue d'une distribution une fois que l’on a retiré les 25% des valeurs les plus faibles et les 25% des valeurs les plus fortes.

[Écart absolu moyen]{.div_voc_title}

Moyenne de la valeur absolue des écarts à la moyenne. Autrement dit, c’est la distance moyenne à la moyenne.

[Écart absolu médian]{.div_voc_title}

Moyenne des écarts à la médiane.

[Variance(σ2) et écart-type(σ)]{.div_voc_title}

Indicateurs de la dispersion des valeurs des individus autour de la moyenne. La variance est la moyenne des carrés des écarts à la moyenne. L’écart-type est sa racine carrée. Ce sont des **paramètres de dispersion.**

$$\sigma^x = \sqrt{ \frac{\sum_{i=1}^{n}(x_i - \mu)^2} {n}} $$

[Coefficient de variation]{.div_voc_title}

Le coefficient de variation (CV) est le rapport de l'écart-type à la moyenne. Le coefficient de variation, également nommé écart type relatif, est une mesure de dispersion relative. Plus la valeur du coefficient de variation est élevée, plus la dispersion autour de la moyenne est grande. Il est généralement exprimé en pourcentage. Sans unité, il permet la comparaison de distributions de valeurs dont les échelles de mesure ne sont pas comparables.

$$CV = \frac{\sigma }{\mu } $$
:::

### Discrétiser une distribution

::: div_voc
**Discrétiser revient à rendre discret des valeurs continues**. Cela consiste à classer les valeurs quantitatives d'une série statistique par intervalle de valeur selon des critères justifiables **afin d'en améliorer la lecture**.

L'ensemble des classes (intervalles de valeurs) créé forme ainsi une partition de toutes les valeurs possibles de la variable.

Exemple :\
Il est par exemple possible de discrétiser les valeurs d'un variable s’échelonnant de 1 à 25, en construisant les classes suivantes : \[min à 5\] - \[6 à 10\] - \[11 à 15\] - \[16 à 20\] - \[21 à max\]
:::

### Normaliser une distribution

::: div_voc
**La normalisation d'une (ou plusieurs) série(s) de données est nécessaire quand l'incompatibilité des unités de mesures entre les variables peut affecter les résultats** sans apporter d'interprétations claires. Elle permet d'ajuster une série (vecteur) de valeurs suivant une fonction de transformation **pour les rendre comparables** avec quelques points de référence spécifiques.

Deux exemple de normalisation :

-   Transformation en pourcentage (en ligne, en colonne ou les deux):

![](figures/normalisation1.png)

-   Standardisation (centrer-réduire):

Il s'agit d'un centrage par rapport à la moyenne puis d'une réduction par rapport à l'écart-type :

$$Y_{i} =\frac{X_{i} - \bar{x}}{\sigma^x }$$

![](figures/normalisation2.png)
:::

## Résumer une variable

Avant de décrire, analyser une ou plusieurs variables statistiques, **il est indispensable de contrôler et d'explorer les données. Cela permet de détecter des incohérences et les caractéristiques des données étudiées, afin de correctement les traiter**.

**Comment se structure la table de données** ? Est-elle correctement construite et renseignée ?\
Comment sont nommées les individus et les variables ?\
**Quelle est la classe de données** des différentes variables (numérique, chaîne de caractère, booléenne...) ?\
**Quelles sont les types des variables** stockées (quantitative, qualitative...) ?

Dans un premier temps, nous utiliserons des données mises à disposition par le **package** [questionr]{.package}, qui contient des variables qualitatives. **Installez** ce package, puis **chargez la librairie et les données associées** "*`hdv2003`*" :

```{r,eval=TRUE}
# install.packages("questionr")
library(questionr)

# Chargement des données fournies par le package questionr
data(hdv2003)
```

**Prenez quelques minutes pour explorer ce tableau de données**. Vous pouvez utiliser l'interface Rstudio, mais également un certain nombre de fonctions primitives :

```{r eval=FALSE}

# Quelques exemple
View()
str()
colnames()
row.names()
dim()
class()
is.na()
colSums(is.na())


```

**Les données vous semblent-elles cohérentes et correctement typées dans R ?**

### La distribution

Lorsque l'on étudie une variable, on s’intéresse rapidement à **la distribution de sa série statistique**. Pour cela, on peut calculer la **table de fréquence** (nombre d'individus par valeur, classe de valeur ou par modalité). Sous R, le procédé est différent selon le type de variable étudié :

#### Variable qualitative : fréquence des individus par modalités.

Utilisez les fonctions [table()]{.fonction} ou [prop.table()]{.fonction} :

```{r}

# Nb d'individus par modalité
table(hdv2003$occup)

# Effectifs relatifs (%)
prop.table(table(hdv2003$occup))

```

Pour **représenter graphiquement votre table de fréquence** :

```{r}

# Utilisation d'une librairie de palettes de couleur
# install.packages("RColorBrewer")
library("RColorBrewer")

# Histogramme
barplot(table(hdv2003$occup), col=brewer.pal(n = 9,  "Paired"), las=2 ,cex.names=0.6)

```

#### Variable quantitative: fréquence des individus par classe.

Pour faciliter l'exploration de la distribution d'une variable quantitative, **il est souvent nécessaire de discrétiser la série statistique** en plusieurs classes d'amplitude égale, **car (en général) aucune valeur n'est identique**.

**Pour construire l'histogramme d'une distribution discrétisée en plusieurs classes d'amplitude égale, utilisez la fonction** [hist()]{.fonction}.

Dans l'exemple ci-dessous, nous utilisons la variable quantitative `hp` du dataframe `mtcars` :

```{r}

# Pour représenter la distribution d'une série statistique sans la discrétiser préalablement -> hist()
hist(mtcars$hp, breaks=12, probability = TRUE)

```

### Les valeurs centrales

En plus de l'histogramme, **des résumés numériques (valeurs centrales, paramètres de dispersion absolue et relative) peuvent être calculés pour les variables quantitatives**.

A noter que **le mode** peut être également calculé pour les variables **qualitatives ordinales et nominales**, et **la médiane** peut être calculé pour les variables **qualitatives ordinales**.

#### Moyenne

```{r}

mean(mtcars$hp)

```

#### Médiane

```{r}

median(mtcars$hp)

```

#### Mode

```{r}

# Mode = Valeurs qui a la fréquence la plus élévée
result <-  as.data.frame(table(mtcars$hp))

# Trier les valeurs par leur fréquence -> order()
result[order(result$Freq, decreasing = TRUE),]


```

### Les paramètres de dispersions absolue

Les **paramètres de dispersion absolue** se calculent uniquement sur les **variables quantitatives**.

#### Minimum

```{r}

min(mtcars$hp)

```

#### Maximum

```{r}

max(mtcars$hp)

```

#### Amplitude (étendue)

```{r}

max(mtcars$hp) - min(mtcars$hp)
```

#### Quartiles

```{r}

quantile(mtcars$hp)

```

#### Quartiles, Moyenne et NA's

```{r}

summary(mtcars$hp)
```

#### Intervalle inter-quartile (Q3 - Q1)

```{r}

summary(mtcars$hp)[5] - summary(mtcars$hp)[2]
```

#### Variance

```{r}
var(mtcars$hp)
```

#### Écart-type

```{r}
sd(mtcars$hp) 
```

#### Coefficient de variation (en %) -

```{r}
# = Ecart-type/moyenne * 100
sd(mtcars$hp) / mean(mtcars$hp) *100
```

## Discrétiser une variable

**Il est nécessaire de définir la forme d'une la distribution pour la discrétiser correctement**.

Ci-dessous, quelques **formes classiques de distribution statistique** :

![](figures/forme_distribution_2.png?style=centerme)

::: div_voc
**En fonction du profil d'une distribution**, on utilise **différentes méthodes de discrétisation :**

[Amplitude égale]{.div_voc_title}

Longueur de l'intervalle entre la valeur minimum et maximum.

Toutes **les classes ont la même amplitude**. -\> A privilégier pour les **distributions uniformes ou symétriques**.

[Discrétisation standardisée]{.div_voc_title}

Les classes sont déterminées selon une **fraction d’écart-type par rapport à la moyenne**. -\> A privilégier pour les **distributions symétriques**.

[Par seuil observé]{.div_voc_title} Les bornes sont **créées par observation de la distribution, de manière manuelle**. -\> A privilégier pour les **distributions dissymétriques et/ou bimodales**.

[Effectifs égaux (quantiles)]{.div_voc_title} Les bornes sont construites en réalisant des **classes d’effectifs égaux**. -\> A privilégier pour les **distributions dissymétriques et/ou bimodales**.

[Q6]{.div_voc_title} **Variante de la discrétisation selon les quantiles** avec **isolement des classes extrêmes** de la série. -\> A privilégier pour les **distributions dissymétriques et/ou bimodales**.

[Fisher-Jenks]{.div_voc_title} Les classes construites **maximisent la variance inter-classe** et **minimisent la variance intra-classe**. -\> A privilégier pour les **distributions dissymétriques et/ou bimodales**.

[Progression géométrique]{.div_voc_title} Les classes sont **découpées selon une progression géométrique**. -\> A privilégier pour les **distributions dissymétriques**.

[Progression arithmétique]{.div_voc_title} Les classes sont établies **selon une progression arithmétique**. -\> A privilégier pour les **distributions dissymétriques**.
:::

::: {.callout-important title="Important !"}
**Le choix d'un méthode de discrétisation et du nombre de classes à un impact très important sur l'interprétation de sa représentation visuelle. Cette [application](http://mappemonde.mgm.fr/geovisu/119/" onclick="window.open(this.href); return false;) [@geovisujegou] en est une belle démonstration.
:::

Pour discrétiser une série statistique, vous pouvez utiliser la **fonction** \* [mf_get_breaks()]{.fonction}, du package [mapsf]{.package} [@mapsf].

```{r, include=FALSE }
# install.packages("mapsf")
library(mapsf)

ma_discretisation <- mf_get_breaks(mtcars$hp, breaks = "quantile", nbreaks = 6)
ma_discretisation

```

Vous pouvez choisir différentes méthodes de discrétisation avec l'argument '*breaks*'.

```{r, eval = FALSE}

# Pour accéder à la documentation de la fonction :
?mf_get_breaks

```

Pour **enregistrer l'appartenance des individus aux différentes classes en fonction de la discrétisation**, procédez de la manière suivante :

```{r, eval = TRUE}

# Calcul des borne de classe
ma_discretisation <- mf_get_breaks(mtcars$hp, breaks = "sd")

# Utiliser la fonction cut()
mtcars$hp_classe <- cut(mtcars$hp, 
                        breaks = ma_discretisation, 
                        include.lowest = TRUE, 
                        right = TRUE)

mtcars$hp_classe 


# Préciser des nom de classe avec l'argument labels
mtcars$hp_classe <- cut(mtcars$hp, 
                        breaks = ma_discretisation, 
                        labels =  c("A","B","C","D","E","F","G","H","I"), 
                        include.lowest = TRUE, 
                        right = TRUE)

mtcars$hp_classe 


# Pour changer les noms de classe
levels(mtcars$hp_classe) <- c("Aa","Bb","Cc","Dd","Ee","Ff","Gg","Hh","Ii")
mtcars$hp_classe

# Visualiser le nombre d'éléments par classe - table()
table(mtcars$hp_classe)

```

### Représentation graphique

#### L'histogramme

```{r warning=TRUE, message=FALSE, eval = TRUE}

# Afficher l'histogramme de la distribution
hist(mtcars$hp, breaks = 15, col = "grey", main = "Distribution de la variable hp")

# Ajouter la moyenne
abline(v=mean(mtcars$hp, na.rm=TRUE), col = "red", lwd = 4 , lty = 2 )

# Ajouter les bornes des classes
abline(v=ma_discretisation,col="blue", lwd = 2, lty = 2)

# Ajouter une légende
legend("topright", c("moyenne", "borne de classe"), fill= c(col="red", col="blue"), cex=0.8)

# Affichage de chaque individu
rug(mtcars$hp)

```

#### La boite à moustaches (boxplot) :

![](figures/boxplot.png?style=centerme){width="350px"}

```{r}

# Boite à moustache
boxplot(mtcars$qsec,
        main = "Distribution variable quantitative continue 'qsec'",
        xlab = "qsec",
        col = "orange",
        border = "brown",
        horizontal = TRUE)

# ajouter la série statistique en bas du boxplot
rug(mtcars$qsec)


```

#### La carte

**La carte permet d'explorer la répartition spatiale d'une distribution d'une variable géographique**. Plusieurs packages permettent de faire des carte avec R, **le package** [mapsf]{.package} **est spécialisé dans la production de cartes thématiques et statistiques**.

\![figures/carto.png\]{width = 50%} *Source : https://riatelab.github.io/mapsf/index.html*

**Un exemple d'utilisation...**

1)  Préparation des données :

```{r, include=TRUE}

# Import de la couche géographique
library(sf)
mtq <- st_read("data/martinique.shp")

# Import des données de recensement
mtq_data <- read.csv("data/INSEE_COM_972.csv", header=TRUE, sep=",", stringsAsFactors=FALSE)

# Jointure shapefile - data
mtq <-  merge(mtq , mtq_data , by.x="INSEE_COM" , by.y="CODGEO")

# Calcul d'une variable quantitative relative (Densité de population)
mtq$POPDENS <- 1e6 * mtq$P16_POP / st_area(mtq)

# Calcul discrétisation 
ma_discretisation <- mf_get_breaks(mtq$POPDENS, breaks = "quantile")
```

2)  cartographie :

```{r, eval=TRUE}

library(mapsf)

# Choix d'un thème graphique
mf_theme("iceberg")

# Carte par aplat de couleur
mf_map(x = mtq, 
       var = "POPDENS",
       type = "choro",
       breaks = ma_discretisation,
       pal = "Greens",
       border = "white", 
       lwd = 0.5,
       leg_pos = "left", 
       leg_title = "Population Density\n(people per km2)") 

# Mikse en page
mf_layout(title = "Population Distribution in Martinique", 
          credits = paste0("Sources: Insee and IGN, 2018\n",
                           "mapsf ", 
                           packageVersion("mapsf")))

```

## Exercice

::: exercice
1)  **Créez un nouveau projet** (ou réutilisez le projet créé durant l'exercice 1).

2)  **Chargez de nouveau le fichier** ***INSEE_COM_972.csv***, stocké dans le sous-répertoire 'data' de votre projet.

3)  **Sélectionnez uniquement ces variables** et créez un nouveau dataframe :

    -   Code insee de la commune (**CODGEO**)\
    -   Nom de la commune (**LIBGEO**)\
    -   Libellé aire urbaine (**LIBAU2010**)\
    -   Catégorie commune dans aire urbaine (**CATAEU2010**)\
    -   Population total en 2016 (**P16_POP**)\
    -   Nombre de personnes de 15 ans et plus en 2016 (**C16_POP15P**)\
    -   Nombre d'agriculteurs et exploitants de 15 ans et plus (**C16_POP15P_CS1**)\
    -   Nombre de retraités de 15 ans et plus (**C16_POP15P_CS7**)

4)  **Créez une nouvelle variable : la part de la population d'agriculteurs et exploitants dans la population active**, et **nommez cette nouvelle variable** ***TX_CS1_2016***

    -   Quel est le taux minimum ?\
    -   Quel est le taux maximum ?\
    -   Quel est l'amplitude de la variable ?\
    -   Quelle est la moyenne ?
    -   Quel indicateur divise la série statistique en deux ? Quelle est sa valeur ?\
    -   Quel est son écart-type, son intervalle interquartile ?\
    -   **Représentez graphiquement la distribution** ? (plusieurs solutions sont possibles)

5)  **Discrétisez la variable** ***TX_CS1_2016***. Quelle méthode choisissez-vous ? Pourquoi ?

6)  **Créez une variable qualitative à partir des valeurs de la variable** \***TX_CS1_2016**. Plusieurs solutions sont possible, exemple :

-   Utiliser la fonction [cut()]{.fonction}
-   Utiliser un opérateur relationnel... (si TX_CS1_2016 \< ..., alors CAT_CS1_2016 == "FAIBLE"...)

7)  **Réaliser une jointure entre la couche géographique de la Martinique et le tableau de données INSEE**.

8)  **Cartographiez la part d'agriculteurs et exploitant dans la population active**.
:::

# Statistique bivariée

## Vocabulaire

::: div_voc
[Statistique bivariée]{.div_voc_title}

C'est l’étude des relations entre deux variables, quantitatives et/ou qualitatives. Les analyses bivariées consistent ainsi à étudier des variables prises en couple, via des techniques descriptives ou probabilistes. L’objectif est de **mettre en évidence un lien ou une absence de lien entre 2 variables, et d'étudier ce lien (sens, intensité)** lorsqu'il existe.

L’analyse d’une relation bivariée avec deux types de variables possibles se résume à trois cas :\
1- Relation entre **deux variables qualitatives** (3.2)\
2- Relation entre **une variable qualitative et une variable quantitative** (3.3)\
3- Relation entre **deux variables quantitatives** (3.4)

[Test statistique]{.div_voc_title}

Un test statistique est une procédure de décision entre deux hypothèses. Il s'agit d'une démarche consistant à rejeter ou à ne pas rejeter une hypothèse statistique, appelée hypothèse nulle, en fonction d'un jeu de données (échantillon).

[Corrélation]{.div_voc_title}

Mesure du lien d’association entre des phénomènes (variables) décrits par des séries statistiques. Le calcul d'une corrélation entre deux variables permet de savoir si elles sont liées. Attention, deux variables peuvent être fortement liées sans que l'une n'explique l'autre : https://www.tylervigen.com/spurious-correlations

[Tableau de contingence *(tableau croisé)*]{.div_voc_title}

Pour déterminer s'il existe une relation entre deux variables étudiés, on construit un tableau de contingence.Les valeurs du tableau correspondent aux effectifs de population selon les modalités des deux variables. Ex :

![](figures/contingency.png)

::: {.callout-tip title="Remarque"}
La construction d'un tableau de contingence est la première étape nécessaire pour évaluer la dépendance de deux variables qualitatives.
:::

[Résidu]{.div_voc_title}

Les résidus d’une régression expriment l’écart entre les valeurs observées et les valeurs prédites par le modèle. Plus un individu aura des résidus forts (positifs ou négatif), moins sa position sera expliquée par le modèle. Il faudra alors trouver d’autres facteurs explicatifs.
:::

## Deux variables qualitatives

**Un couple de variables qualitatives se décrit par ses fréquences conjointes dans un tableau *tris croisés*** . Les fréquences obtenues peuvent être calculées par rapport à l’effectif total ou par rapport aux effectifs marginaux (effectif en ligne et colonne). **Il s'agit de l’une des analyses les plus fréquentes lors du traitement d’enquêtes en sciences sociales**.

### Tableaux croisés

La manière la plus simple d’obtenir un tableau croisé est d’utiliser la fonction [table()]{.fonction}.

```{r}

# Utilisation d'un jeu de donnéesdu package 'questionr'
head(hdv2003,3)

# tableau croisé avec table()
table(hdv2003$sport, hdv2003$qualif)

```

```{r, eval=FALSE}

# Croiser trois variables ou plus
table(hdv2003$sport, hdv2003$cuisine, hdv2003$sexe)

```

Il est cependant difficile de comparer à partir des effectifs. **Le package** [questionr]{.package} fournit des fonctions permettant de calculer facilement les pourcentages lignes, colonnes et totaux d’un tableau croisé.

Les pourcentages en lignes ou en colonne s’obtiennent avec les fonctions [rprop()]{.fonction} et [cprop()]{.fonction}. Celles-ci s’appliquent au tableau croisé généré avec [table()]{.fonction} :

```{r}

# Pourcentage en ligne d'un tableau croisé table(), avec lprop() du package 'questionr'
rprop(table(hdv2003$sport, hdv2003$cuisine))

# Pourcentage en colonne d'un tableau croisé table(), avec cprop() du package 'questionr'
cprop(table(hdv2003$sport, hdv2003$cuisine))

```

Les pourcentages totaux s’obtiennent avec la fonction [prop()]{.fonction}

```{r}

# Pourcentages totaux d'un tableau croisé
prop(table(hdv2003$sport, hdv2003$cuisine), 
     digit=2, 
     percent=TRUE)


```

### Le khi-2 (χ²) et la mesure des écarts à l’indépendance

A partir d’un tableau croisée, **on peut tester l’existence d’un lien entre les modalités de deux variables** avec le **test du χ²**.

::: div_voc
Le [**test du χ²**]{.div_voc_def} **consiste à comparer la répartition observée à une répartition théorique sous hypothèse d’indépendance**, c’est-à-dire la répartition que l’on observerait s’il n’y avait aucun lien entre les deux variables. Cette répartition théorique consiste donc à redistribuer les effectifs conjoints tout en conservant les effectifs marginaux.

**Le test du χ² permet d’établir à quel seuil de probabilité on peut rejeter l’hypothèse d’indépendance** entre des effectifs observés et des effectifs théoriques. **Plus le χ² est proche de zéro, plus le tableau des effectifs théoriques et celui des effectifs observées se confondent.**

**Un test de χ² s’applique uniquement sur des tableaux de contingence :**\
- ayant **au moins 2 lignes et 2 colonnes**\
- contenant des **valeurs positives entières**\
- ayant au **minimum 5 observations par cases** du tableau et/ou dans le tableau des effectifs théoriques.

**Lorsque toutes les cases du tableau n’ont pas plus de 5 observations par cases, il est conseillé d’effectuer des regroupement de modalités** lorsque c’est possible.
:::

La fonction [chisq.test()]{.fonction} permet de réaliser un test du du χ². Cette fonction renvoie une liste qui contient tous **les éléments nécessaires à l’analyse du χ² : effectifs théoriques, résidus bruts ou résidus relatifs** :

```{r}
# 1) construction du tableau de contigence avec les effectifs réels
tab <- table(hdv2003$sport, hdv2003$qualif)

# 2) Test du Khi-2 sur le tableau de contingence
tab.chi2 <- chisq.test(tab)
tab.chi2
```

**La fonction** [chisq.test()]{.fonction} renvoie automatiquement :

-   la **statistique du χ2**(X-squared)\
-   le **degré de liberté** associé au test (df)\
-   la **significativité de la relation** (p-value)

::: callout-important
## Interpréter les résultats ?

***"La probabilité d’obtenir une valeur du χ² observée aussi élevée dans un échantillon de la taille observée sous l’hypothèse d’indépendance des deux variables est inférieure à 0.001%. Il est donc possible de rejeter l’hypothèse d’indépendance"***.

Il semble bien exister une relation entre la CSP et la pratique du sport...
:::

**L'objet liste renvoyé contient également :**

```{r}
# Les effectifs observés
tab.chi2$observed

# Les effectifs théoriques
tab.chi2$expected

```

**Pour correctement interpréter le résultat du test du χ², il est important de comprendre comment ces différentes valeurs sont calculées...**

--\> [Le calcul du χ² et du degré de liberté ?](https://github.com/HuguesPecout/Initiation_R_stats/raw/main/Khi2.xls)\
--\> Le calcul de la valeur p ([table de la loi du χ² ?](https://jpcmanson.wordpress.com/2015/08/13/statistiques-les-omega-3-previennent-ils-lapparition-des-troubles-psychiatriques/khi2/))

Il est possible d'**affiner l’interprétation du test en déterminant dans quelle "case" l’écart à l’indépendance est le plus significatif en utilisant les résidus du test**. Ceux-ci sont notamment affichables avec la fonction [chisq.residuals()]{.fonction} de la librairie [**questionr**]{.package} :

```{r}

# Résidus (de Pearson) du test khi-2 = (obs - exp) / sqrt(exp)

# tab.chi2$residuals fonctionne aussi !
chisq.residuals(tab)


```

### Représentations graphiques

#### Le tableau de contingence

```{r}
tab <-  table(hdv2003$sport, hdv2003$qualif)

# Diagramme en bâton - Effectifs observés
barplot(tab, 
        main = "Pratique du sport selon le niveau de qualification\nEffectifs observés", 
        las=2)

legend("topright", 
       c("NON", "OUI"), 
       fill=c(col="grey40", col="grey90"), 
       cex=0.8)


# Diagramme en bâton - Fréquence des effectifs observés
barplot(cprop(tab, total = FALSE), 
        main = "Pratique du sport selon le niveau de qualification\nFréquences relatives des effectifs",
        las=2)

legend("topright",
       c("NON", "OUI"), 
       fill=c(col="grey40", col="grey90"), 
       cex=0.8)


```

#### Les résidus Pearson d'un test du χ²

La fonction [mosaicplot()]{.fonction} permet un représentation graphique du tableau de contingence des effectifs observés et des résidus de Pearson du test du χ² ((obs - exp) / sqrt(exp)).

la longueur des segments sur les deux axes correspond aux fréquences relatives correspondantes et **l’aire des rectangles est également proportionnelle à la fréquence relative de la sous-population représentée**. **La couleur de la case correspond aux résidus Pearson du test du χ²** :

```{r}

# Fonction mosaicplot()
mosaicplot(qualif ~ sport, 
           data = hdv2003, 
           shade = TRUE, 
           main = "Résidus de Pearson du test du χ²", 
           cex=0.6)

```

**les cases en rouge sont sous-représentées, les cases en bleu sur-représentées, et les cases blanches sont statistiquement proches de l’hypothèse d’indépendance.**

## Exercice

::: exercice
Dans le le tableau ci-dessous figurent en colonnes le nombre de réponses à la question "***Faites-vous faire des recherches sur internet à vos élèves ?***" posée à 179 enseignants de collèges en France :

![](figures/chi2.png?style=centerme)

1)  **Construire le `data.frame` dans R correspondant à ce tableau de contingence **.

```{r, echo=FALSE, eval=FALSE}
library(questionr)
mon_tableau <- data.frame(oui=c(68, 37), non=c(60,14), row.names=c("dom", "sec"))

questionr::cprop(as.matrix(mon_tableau))

x <- chisq.test(mon_tableau)
x$residuals

```

2)  **Convertissez les valeurs en fréquence relative** (en ligne, colonne et total).

3)  **Représenter graphiquement les fréquence relatives** à l'aide de la fonction [barplot()]{.fonction}.

```{r fig.width=5, echo=FALSE, eval=FALSE}

Attention, vous devez dans un premier temps convertir votre data.frame en matrix... 
barplot(cprop(t(as.matrix(df)))[1:2,1:2])

```

4)  **Réalisez un test du χ²**. **Existe-t-il un lien statistique entre ces deux variables ?**

5)  **Représentez graphiquement les résidus de Pearson du test du χ²** avec la fonction [mosaicplot()]{.fonction}.
:::

## Qualitatif vs Quantitatif

Il existe plusieurs méthodes statistiques pour mesurer la dépendance entre une variable qualitative et une variable quantitative, comme le test **t de student** ou **l'analyse de variance (ANOVA)**. Cependant, **ces méthodes ne seront pas détaillé dans ce cours**...

Exemple de calcul du test t de student avec R ([t.test()]{.fonction}) :

```{r fig.width=5}

# Nécessite une variable qualitative binaire (deux modalités max)
test.student <- t.test(age ~ sport, data = hdv2003)
test.student
```

Exemple d'une analyse de variance avec R ([aov()]{.fonction}) :

```{r fig.width=5}

# Nécessite une variable qualitative binaire (deux modalités max)
anova <- aov(age ~ sport, data=hdv2003)
anova
```

### Comparaison d’indicateurs

**Comparer certains indicateurs (moyenne, médiane...) d’une variable quantitative selon les modalités d’une variable qualitative** permet de mesurer des différence entre plusieurs sous-population.

Dans un premier temps, **ventilez votre population en autant de sous-populations qu’il y a de modalités dans la variable qualitative**. Pour cela, utilisez la fonction [**subset()**]{.fonction} :

```{r}

# On crée deux tables de sous-population

# Sous-population pratiquant du sport :
hdv2003_sport <- subset(hdv2003, sport == "Oui")
# Sous-population non-pratiquante :
hdv2003_nonsport <- subset(hdv2003, sport == "Non")

```

```{r}

# Moyenne d'age des pratiquants
mean(hdv2003_sport$age)

```

```{r}

# Moyenne d'age des non-pratiquants
mean(hdv2003_nonsport$age)

```

Vous pouvez également utiliser la fonction [tapply()]{.fonction}, qui prend en paramètre une variable quantitative, qualitative et une fonction, puis applique automatiquement la fonction aux valeurs de la variables quantitative pour chaque niveau de la variable qualitative. Ex :

```{r}

# Fonction tapply()
tapply(hdv2003$age, hdv2003$sport, mean)

```

### Représentations graphiques

Il est possible de **résumer visuellement la distribution statistique d’une variable quantitative autour de différentes mesures de centralité et de dispersion en utilisant la "boîte à moustache" (*boxplot*).**

**La fonction** [boxplot()]{.fonction} **représente la distribution de la variable quantitative pour chacune des modalités de la variable qualitative :**

```{r}

# Fonction mosaicplot()
boxplot(hdv2003$heures.tv ~ hdv2003$qualif, 
        col="firebrick3",
        ylab="heures TV",
        las=2)

```

**Dans le cas où une variable qualitative ne présente que deux modalités**, la représentation côte à côte des deux distributions permet d'observer facilement leurs différences :

```{r}

# Construction du tableau croisé, en format data.frame
tab <- as.data.frame(lprop(table(hdv2003$sport, hdv2003$age)))
colnames(tab) <- c("sport", "age", "Freq")
tab <-  subset(tab , !(sport %in% "Ensemble"))

# Utilisation de la fonction ggplot()
library(ggplot2)
ggplot(tab , aes(x = age, y = Freq, fill = factor(sport))) +
  geom_bar(stat = "identity", position = position_dodge(), las=2) +
  ylab("Pourcentage") +
  scale_x_discrete(breaks=seq(17,97,3), labels = seq(17,97,3)) +
  scale_y_continuous(limit=c(0,3.3))
```

## Deux variables quantitatives

### Représentation graphique

Lorsque l'on croise deux variables quantitatives, l’idéal est de faire une représentation graphique sous forme de nuage de points. **Cela permet de visualiser l’existence d’un lien entre les deux variables** et de ne pas faire d'erreurs d'interprétation.

Figure : Différentes séries statistiques... aux paramètres identiques

![](figures/DataSaurus.gif)

Source : http://blog.revolutionanalytics.com/2017/05/the-datasaurus-dozen.html

**Commencez par charger le jeu de données du recensement de la population de 2012** (***rp2012***) mis à disposition par le package [questionr]{.package}.

```{r}
library(questionr)
data(rp2012)
```

Pour tracer un nuage de points, utilisez la fonction [plot()]{.fonction} :

```{r}

plot(rp2012$cadres, rp2012$dipl_sup)

```

Il est possible de **personnaliser le graphique...**

```{r warning=TRUE, message=FALSE, fig.width=5, fig.height=5}

par(bg = "ivory", mar = c(2,2,2,2), family="")
plot(x = rp2012$cadres, y = rp2012$dipl_sup, asp = 1, pch = 21, col = "white", 
     ylim = c(0,60), cex = 0.5, bg = "red", lwd = 0.5, axes = F)
axis(side = 1, at = seq(from = 0,to = 60, by = 10), cex.axis = 0.8,
     pos = 0, tck=-0.01, padj = -1)
axis(side = 2, at = seq(from = 0,to = 60, by = 10), cex.axis = 0.8,
     labels = c("", seq(from = 10,to = 60, by = 10) ), pos = 0, tck=-0.01, las = 2)
mtext(text = "Relation entre niveau d'étude et CSP", side = 3, line = 0.75,
      adj = 0,font = 4)
mtext(text = "Diplômés du supérieur (%)", side = 2, line = 1)
mtext(text = "Cadres (%)", side = 1, line = 1)

```

### Interpréter un nuage de points

Quelques **formes classiques de relation entre 2 variables** :

\![figures/correlation.png\]

*Source : https://eric.univ-lyon2.fr/\~ricco/cours/cours/Analyse_de_Correlation.pdf*

### Calcul d’indicateurs

En plus d’une représentation graphique, on peut calculer **certains indicateurs permettant de mesurer le degré d’association de deux variables quantitatives**.

#### Corrélation linéaire (Pearson)

**La corrélation est une mesure du lien d’association linéaire entre deux variables quantitatives**. **Sa valeur varie entre -1 et 1**. Si la corrélation vaut -1, il s’agit d’une association linéaire négative parfaite. Si elle vaut 1, il s’agit d’une association linéaire positive parfaite. **Si elle vaut 0, il n’y a aucune association linéaire entre les variables.**

**Le calcul du coefficient linéaire peut se faire avec la fonction [cor.test()]{.fonction}** :

```{r}

# Fonction primitive cor.test()
cor.test(rp2012$cadres, rp2012$dipl_sup) 

```

Dans ce cas, **le coefficient est extrêmement fort. Il y a donc un lien linéaire et positif entre les deux variables** (quand la valeur de l’une augmente, la valeur de l’autre augmente également).

#### Corrélation des rangs (Spearman)

Si les deux variables ne semblent pas être corrélées de façon linéaire et que l'on est en présence d’une relation monotone (c'est à dire que les variables ont tendance à se déplacer dans la même direction relative), on peut utiliser **le coefficient de corrélation des rangs de Spearman**.

Plutôt que de se baser sur les valeurs des variables, **cette corrélation va se baser sur leurs rangs**, c’est-à-dire sur leur position parmi les différentes valeurs prises par les variables.

Ainsi, si la valeur la plus basse de la première variable est associée à la valeur la plus basse de la deuxième, et ainsi de suite jusqu’à la valeur la plus haute, on obtiendra une corrélation de 1. Si la valeur la plus forte de la première variable est associée à la valeur la plus faible de la seconde, et ainsi de suite, et que la valeur la plus faible de la première est associée à la plus forte de la deuxième, on obtiendra une corrélation de -1. Si les rangs sont “mélangés”, sans rapports entre eux, on obtiendra une corrélation autour de 0.

**Pour calculer une corrélation de Spearman, utilisez la fonction [cor()]{.fonction}** (argument method = "spearman") :

```{r}
# Calcul coefficient de Corrélation de Spearman
cor(rp2012$cadres, rp2012$dipl_sup, method = "spearman")
```

### Régression linéaire

Dans le cas particulier où l'**on a pu mettre en évidence l'existence d'une relation linéaire significative entre deux caractères quantitatifs continus X et Y, on peut chercher à formaliser la relation moyenne qui unit ces deux variables** à l'aide des équations suivantes :

**Y = aX + b** = droite de régression de Y en fonction de X\
**X = aY + b** = droite de régression de X en fonction de Y

La régression consiste à évaluer les paramètres d’une fonction linéaire, puis d'estimer à l’aide de cette fonction les valeurs de la variable à expliquer et à tester si les différences (= les résidus) entre valeurs mesurées et valeurs estimées s’écartent de manière significative de 0.

```{r}

# Regression linéaire - fonction lm()
lm(rp2012$cadres ~ rp2012$dipl_sup)

```

[lm()]{.fonction} **nous renvoie les coefficients de la droite de régression, où :**

**Y** = % de cadres\
**X** = % diplomé du supérieur

**b** = **ordonnée à l’origine** (Intercept) vaut **0.92** **a** = **le coefficient** associé à dipl_sup vaut **1.08**

**La régression linéaire de Y en fonction de X** ( Y = aX + b ) équivaut donc à **Y = 1.08X + 0.92**

#### Coefficient de détermination (R2)

Le coefficient de détermination (R2) est une mesure de la qualité de la prédiction d’une régression linéaire. Il donne la part de la variance expliquée par l’équation de la régression dans la variance totale du nuage de points.

**Pour calculer le R2, combinez les fonctions [summary()]{.fonction} et [lm()]{.fonction} :**

```{r}
# Pour des résultats plus détaillés, fonction summary :
summary(lm(rp2012$cadres ~ rp2012$dipl_sup))
```

#### Représentation graphique

On peut enfin **représenter la droite de régression** sur notre nuage de points à l’aide de la **fonction [abline()]{.fonction}** :

```{r}


plot(rp2012$dipl_sup, rp2012$cadres)
abline(lm(rp2012$cadres ~ rp2012$dipl_sup), col="red", lwd=2)
text(6, 55, "y = 1.08x + 0.92", col="red")

```

### Les résidus

**Les résidus d’une régression expriment l’écart entre les valeurs observées et les valeurs prédites par le modèle**. Plus un individu aura des résidus forts (positifs ou négatif), moins sa position sera expliquée par le modèle. Il faudra alors trouver d’autres facteurs explicatifs.

**Calculer les résidus :**

```{r}

# Regression lineaire
my_reg <- lm(rp2012$cadres ~ rp2012$dipl_sup)

# Construction d'un data.frame des résidus normalisés
residus <- data.frame(scaledRes = scale(my_reg$residuals), nom = row.names(rp2012))

```

**Représenter les résidus :**

```{r}
# on ne garde que le nom des individus ayant des résidus trés élevés (sup à 4 ecarts-type)
residus[residus$scaledRes < 4 & residus$scaledRes > -4, "nom"] <- NA

# affichage des résidus
plot(residus$scaledRes, cex = .5, pch = 20, ylim=c(-5,5))
# intervalles exprimés en ecart-type
abline(h = 0, lwd = 2, col = "red")     
abline(h = 4, lty = 2)
abline(h = -4, lty = 2)
# affichage du nom des individus extraordinaires
text(x= 1:nrow(residus), y = residus$scaledRes, labels = residus$nom, pos = 4, 
     cex = 0.7, offset = c(.2,0), font = 2)

```

## Exercice

::: exercice
Pour cet exercice, utilisez le jeu de données ***women*** (R-base).

```{r class.source="bg-danger",, eval=FALSE}

?women
data(women)
head(women)

```

1)  **Créez un nouveau projet.**

2)  **Décrivez le jeu de données "women"**. Quelles sont les unités de mesure des variables ?

3)  **Créer deux nouvelles variables (taille et poids)** dans des unités de mesures plus compréhensibles. Arrondissez les valeurs pour une meilleure lisibilité (avec quelles fonctions ?).

4)  **Créez un graphique mettant en relation les deux variables** (poids et taille).

5)  **Quelle hypothèse pouvons-nous faire ? Et comment la vérifier ?**

6)  **Quelle est la relation entre poids et taille ?**

7)  **Comment modéliser cette relation ?**

8)  **Quel serait le poids d'une femme d'1.68 m ?**

9)  **Afficher la droite de régression** du modèle sur le graphique.
:::

# Sources & références

## Langage R

Il existe de **très nombreuses ressources documentaires sur R**, disponible **en libre accès** sur le web. De nombreuses ressources de qualité, parfois largement **utilisées pour produire ce document**, sont référencées sur le site de partage et de diffusion [**rzine.fr**](http://rzine.fr/){target="_blank"} (onglet ***ressources***).

[\![figures/Rzine_logo.png\]](https://rzine.fr/)

## Statistique en géographie (et R)

::: {#refs}
:::

# Info session {.unnumbered}

```{r session_info, echo=FALSE}
#kableExtra::kable_styling(knitr::kable(rzine::sessionRzine()[[1]], row.names = F))
#kableExtra::kable_styling(knitr::kable(rzine::sessionRzine()[[2]], row.names = F))
```
